name: Production Workflow

on:
  push:
    branches:
      - master

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 908027419539.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: my-nginx-app
  ECS_CLUSTER: my-nginx-prod-cluster
  ECS_SERVICE: my-nginx-prod-service
  GREEN_SERVICE_NAME: my-nginx-green-service

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        id: login-ecr

      - name: Build, tag, and push image to Amazon ECR
        env:
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Task Definition
        id: task-def
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Force Delete Existing Green Service
        run: |
          # Verificar si el servicio existe
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $GREEN_SERVICE_NAME \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "INACTIVE")
          
          if [ "$SERVICE_STATUS" != "INACTIVE" ]; then
            # Primero, actualizar el servicio a 0 tareas
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $GREEN_SERVICE_NAME \
              --desired-count 0
            
            # Esperar a que las tareas se detengan
            echo "Waiting for tasks to stop..."
            aws ecs wait services-stable \
              --cluster $ECS_CLUSTER \
              --services $GREEN_SERVICE_NAME
            
            # Ahora sí, eliminar el servicio
            aws ecs delete-service \
              --cluster $ECS_CLUSTER \
              --service $GREEN_SERVICE_NAME \
              --force
          fi

      - name: Wait for Service Deletion
        run: |
          max_attempts=12
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            # Verificar si el servicio existe y su estado
            SERVICE_CHECK=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $GREEN_SERVICE_NAME \
              --query 'services[0].[status,runningCount]' \
              --output text 2>/dev/null || echo "INACTIVE 0")
            
            STATUS=$(echo $SERVICE_CHECK | cut -d' ' -f1)
            RUNNING_COUNT=$(echo $SERVICE_CHECK | cut -d' ' -f2)
            
            echo "Service Status: $STATUS, Running Tasks: $RUNNING_COUNT"
            
            if [ "$STATUS" == "INACTIVE" ] || [ "$STATUS" == "NONE" ]; then
              echo "Service is fully deleted"
              break
            fi
            
            if [ "$RUNNING_COUNT" == "0" ]; then
              echo "No running tasks, service should be safe to replace"
              break
            fi
            
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
              echo "Timeout reached, but proceeding since no running tasks"
              break
            fi
            
            echo "Attempt $attempt of $max_attempts, waiting 5 seconds..."
            sleep 5
          done
          
          # Esperar 10 segundos adicionales para asegurar que AWS haya procesado la eliminación
          sleep 10

      - name: Create Green Service
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
          PUBLIC_SUBNET_IDS: subnet-05b5533b0a8602474,subnet-095b0b27bd626d558,subnet-0247dff8cb76adddf
          SECURITY_GROUP: sg-0e2f023a42da0b442
        run: |
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name $GREEN_SERVICE_NAME \
            --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_IDS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --load-balancers targetGroupArn=$GREEN_TARGET_GROUP_ARN,containerName=my-nginx-app,containerPort=80

      - name: Verify Green Deployment
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
        run: |
          # Esperar a que el servicio esté estable
          sleep 30
          
          # Obtener el ARN de la tarea usando --query directamente
          TASK_ARN=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $GREEN_SERVICE_NAME \
            --query 'taskArns[0]' \
            --output text)

          # Debug: Print the task ARN
          echo "Task ARN: $TASK_ARN"

          # Verificar si se obtuvo un ARN válido
          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" == "null" ]; then
            echo "No se encontró ninguna tarea en ejecución"
            exit 1
          fi

          # Wait for the specific task to reach a steady state
          max_attempts=20
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            # Describe the task to get its status
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks "$TASK_ARN" \
              --query 'tasks[0].lastStatus' \
              --output text)

            echo "Task Status: $TASK_STATUS"

            # Check target group health
            TARGET_HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn $GREEN_TARGET_GROUP_ARN \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)

            echo "Target Health: $TARGET_HEALTH"

            # Break if task is RUNNING and target is healthy
            if [[ "$TASK_STATUS" == "RUNNING" ]] && [[ "$TARGET_HEALTH" == "healthy" ]]; then
              echo "Task is running and healthy"
              break
            fi

            # Si la tarea falló, salir con error
            if [[ "$TASK_STATUS" == "STOPPED" ]]; then
              echo "Task stopped unexpectedly"
              exit 1
            fi

            attempt=$((attempt + 1))
            echo "Attempt $attempt of $max_attempts"
            sleep 30
          done

          # Verificar si se alcanzó el máximo de intentos
          if [ $attempt -eq $max_attempts ]; then
            echo "Se alcanzó el máximo número de intentos sin éxito"
            exit 1
          fi

          # HTTP request to verify application
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.ALB_DNS }})
          echo "HTTP Response Code: $RESPONSE"

          if [ "$RESPONSE" != "200" ]; then
            echo "La aplicación no está respondiendo correctamente"
            exit 1
          fi

          echo "Green Deployment verified successfully"

      - name: Switch Traffic to Green
        run: |
          aws elbv2 modify-listener-rule \
            --listener-rule-arn ${{ secrets.GREEN_LISTENER_RULE_ARN }} \
            --actions Type=forward,TargetGroupArn=${{ secrets.GREEN_TARGET_GROUP_ARN }}

      - name: Clean Up Old Blue Service
        run: |
          aws ecs delete-service \
            --cluster $ECS_CLUSTER \
            --service my-nginx-prod-service \
            --force || true

      - name: Verify Final Deployment
        env:
          ALB_DNS: ${{ secrets.ALB_DNS }}
        run: |
          # Wait for load balancer to route to new service
          sleep 30

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS)

          if [ "$RESPONSE" != "200" ]; then
            echo "Final deployment verification failed"
            exit 1
          fi

          echo "Blue-Green deployment completed successfully"