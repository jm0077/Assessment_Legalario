name: Production Workflow

on:
  push:
    branches:
      - master

jobs:
  create-approval:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Create Approval Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue create \
            --title "Approve Production Deployment" \
            --body "A new deployment is ready for production.

            Details:
            - Repository: ${{ github.repository }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}

            To approve this deployment:
            - Comment '/approve' on this issue

            To deny:
            - Comment '/deny' on this issue"

      - name: Wait for Approval
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            ISSUE=$(gh issue list --limit 1)
            ISSUE_NUMBER=$(echo "$ISSUE" | awk '{print $1}')

            COMMENTS=$(gh issue view $ISSUE_NUMBER --comments)

            if echo "$COMMENTS" | grep -qE "(/approve|LGTM|looks good)"; then
              echo "Deployment approved!"
              exit 0
            fi

            if echo "$COMMENTS" | grep -q "/deny"; then
              echo "Deployment denied!"
              exit 1
            fi

            sleep 30
            attempt=$((attempt + 1))
          done

          echo "Approval timeout reached"
          exit 1

  build-and-push:
    needs: create-approval
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  blue-green-deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Prepare Blue/Green Deployment
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Retrieve current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition my-nginx-task \
            --query "taskDefinition.{family: family, revision: revision}" \
            --output text)
          
          # Update task definition with new image
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --family my-nginx-task \
            --cli-input-json file://task-definition.json \
            --container-definitions "[{
              \"name\": \"my-nginx-app\",
              \"image\": \"$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\",
              \"portMappings\": [{
                \"containerPort\": 80,
                \"hostPort\": 80,
                \"protocol\": \"tcp\"
              }]
            }]" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          # Create green service if it doesn't exist
          aws ecs create-service \
            --cluster my-nginx-prod-cluster \
            --service-name my-nginx-prod-green \
            --task-definition $NEW_TASK_DEF \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[subnet-05b5533b0a8602474,subnet-095b0b27bd626d558,subnet-0247dff8cb76adddf],securityGroups=[sg-0e2f023a42da0b442],assignPublicIp=ENABLED}" || true

      - name: Update Green Service
        run: |
          aws ecs update-service \
            --cluster my-nginx-prod-cluster \
            --service my-nginx-prod-green \
            --task-definition my-nginx-task:$(($(aws ecs describe-task-definition --task-definition my-nginx-task --query 'taskDefinition.revision' --output text)))

      - name: Swap Blue/Green Services
        env:
          LISTENER_ARN: ${{ secrets.LISTENER_ARN }}
        run: |
          # Create new target group
          TARGET_GROUP_ARN=$(aws elbv2 create-target-group \
            --name green-tg-${GITHUB_SHA:0:8} \
            --protocol HTTP \
            --port 80 \
            --vpc-id ${{ secrets.VPC_ID }} \
            --target-type ip \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)

          # Update listener to point to new target group
          aws elbv2 modify-listener \
            --listener-arn $LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN

          # Scale down previous service
          aws ecs update-service \
            --cluster my-nginx-prod-cluster \
            --service my-nginx-service \
            --desired-count 0