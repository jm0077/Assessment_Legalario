name: Production Workflow

on:
  push:
    branches:
      - master

jobs:
  create-approval:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Create Approval Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue create \
            --title "Approve Production Deployment" \
            --body "A new deployment is ready for production.

            Details:
            - Repository: ${{ github.repository }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}

            To approve this deployment:
            - Comment '/approve' on this issue

            To deny:
            - Comment '/deny' on this issue"

      - name: Wait for Approval
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            ISSUE=$(gh issue list --limit 1)
            ISSUE_NUMBER=$(echo "$ISSUE" | awk '{print $1}')

            COMMENTS=$(gh issue view $ISSUE_NUMBER --comments)

            if echo "$COMMENTS" | grep -qE "(/approve|LGTM|looks good)"; then
              echo "Deployment approved!"
              exit 0
            fi

            if echo "$COMMENTS" | grep -q "/deny"; then
              echo "Deployment denied!"
              exit 1
            fi

            sleep 30
            attempt=$((attempt + 1))
          done

          echo "Approval timeout reached"
          exit 1

  build-and-push:
    needs: create-approval
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  blue-green-deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Prepare Green Deployment
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Create or update task definition with new image
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition my-nginx-task \
            --query "taskDefinition.{family: family, revision: revision}" \
            --output text)
          
          FAMILY=$(echo $TASK_DEF | awk '{print $1}')
          REVISION=$(echo $TASK_DEF | awk '{print $2}')
          
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --family $FAMILY \
            --cli-input-json file://task-definition.json \
            --container-definitions "[{
              \"name\": \"nginx-container\",
              \"image\": \"$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\",
              \"portMappings\": [{
                \"containerPort\": 80,
                \"hostPort\": 80,
                \"protocol\": \"tcp\"
              }]
            }]" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          # Ensure green service exists or create it
          GREEN_SERVICE="my-nginx-service-green"
          
          # Check if green service exists
          if ! aws ecs describe-services \
            --cluster my-nginx-prod-cluster \
            --services $GREEN_SERVICE \
            2>/dev/null; then
            
            aws ecs create-service \
              --cluster my-nginx-prod-cluster \
              --service-name $GREEN_SERVICE \
              --task-definition $NEW_TASK_DEF \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[subnet-05b5533b0a8602474,subnet-095b0b27bd626d558,subnet-0247dff8cb76adddf],securityGroups=[sg-0e2f023a42da0b442],assignPublicIp=ENABLED}"
          else
            # Update existing green service
            aws ecs update-service \
              --cluster my-nginx-prod-cluster \
              --service $GREEN_SERVICE \
              --task-definition $NEW_TASK_DEF
          fi

      - name: Wait for Green Service Stability
        run: |
          aws ecs wait services-stable \
            --cluster my-nginx-prod-cluster \
            --services my-nginx-service-green

      - name: Swap Traffic to Green Service
        run: |
          # Get the target group for the green service
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
            --names my-nginx-tg \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)

          # Update load balancer listener to point to green service
          aws elbv2 modify-listener \
            --listener-arn ${{ secrets.LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN

          # Optional: Scale down blue service
          aws ecs update-service \
            --cluster my-nginx-prod-cluster \
            --service my-nginx-service \
            --desired-count 0