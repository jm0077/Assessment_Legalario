name: Production Workflow

on:
  push:
    branches:
      - master

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 908027419539.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: my-nginx-app
  ECS_CLUSTER: my-nginx-prod-cluster
  ECS_SERVICE: my-nginx-prod-service

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        id: login-ecr

      - name: Build, tag, and push image to Amazon ECR
        env:
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Task Definition
        id: task-def
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Delete Existing Green Service if Exists
        continue-on-error: true
        run: |
          aws ecs delete-service \
            --cluster $ECS_CLUSTER \
            --service my-nginx-green-service \
            --force || true

      - name: Create Green Service
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
          PUBLIC_SUBNET_IDS: subnet-05b5533b0a8602474,subnet-095b0b27bd626d558,subnet-0247dff8cb76adddf
          SECURITY_GROUP: sg-0e2f023a42da0b442
        run: |
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name my-nginx-green-service \
            --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_IDS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --load-balancers targetGroupArn=$GREEN_TARGET_GROUP_ARN,containerName=my-nginx-app,containerPort=80

      - name: Verify Green Deployment
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
        run: |
          # Retrieve the task ARNs
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name my-nginx-green-service \
            --query 'taskArns' \
            --output json)

          # Debug: Print out the task ARNs
          echo "Retrieved Task ARNs: $TASK_ARNS"

          # Check if task ARNs are empty
          if [ "$TASK_ARNS" == "[]" ]; then
            echo "No tasks found in the green service"
            exit 1
          fi

          # Parse the first task ARN
          TASK_ARN=$(echo $TASK_ARNS | jq -r '.[0]')

          # Debug: Print the specific task ARN
          echo "Selected Task ARN: $TASK_ARN"

          # Verify task ARN length
          TASK_ARN_LENGTH=${#TASK_ARN}
          echo "Task ARN Length: $TASK_ARN_LENGTH"

          # Wait for the specific task to reach a steady state
          max_attempts=20
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            # Describe the task to get its status
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks "$TASK_ARN" \
              --query 'tasks[0].lastStatus' \
              --output text)

            # Debug: Print task status
            echo "Task Status: $TASK_STATUS"

            # Check target group health
            TARGET_HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn $GREEN_TARGET_GROUP_ARN \
              --query 'TargetHealthDescriptions[*].TargetHealth.State' \
              --output text)

            # Debug: Print target health
            echo "Target Health: $TARGET_HEALTH"

            # Break if task is RUNNING and target is HEALTHY
            if [[ "$TASK_STATUS" == "RUNNING" ]] && [[ "$TARGET_HEALTH" == *"healthy"* ]]; then
              break
            fi

            attempt=$((attempt + 1))
            sleep 30
          done

          # HTTP request to verify application
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.ALB_DNS }})

          # Debug: Print HTTP response
          echo "HTTP Response Code: $RESPONSE"

          # Check conditions
          if [ $attempt -eq $max_attempts ] || [ "$RESPONSE" != "200" ]; then
            echo "Deployment verification failed:"
            echo "Task Status: $TASK_STATUS"
            echo "Target Group Health: $TARGET_HEALTH"
            echo "HTTP Response: $RESPONSE"
            exit 1
          fi

          echo "Green Deployment verified successfully"

      - name: Switch Traffic to Green
        run: |
          aws elbv2 modify-listener-rule \
            --listener-rule-arn ${{ secrets.GREEN_LISTENER_RULE_ARN }} \
            --actions Type=forward,TargetGroupArn=${{ secrets.GREEN_TARGET_GROUP_ARN }}

      - name: Clean Up Old Blue Service
        run: |
          aws ecs delete-service \
            --cluster $ECS_CLUSTER \
            --service my-nginx-prod-service \
            --force || true

      - name: Verify Final Deployment
        env:
          ALB_DNS: ${{ secrets.ALB_DNS }}
        run: |
          # Wait for load balancer to route to new service
          sleep 30

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS)

          if [ "$RESPONSE" != "200" ]; then
            echo "Final deployment verification failed"
            exit 1
          fi

          echo "Blue-Green deployment completed successfully"