name: Production Workflow

on:
  push:
    branches:
      - master

jobs:
  create-approval:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Create Approval Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue create \
            --title "Approve Production Deployment" \
            --body "A new deployment is ready for production.

            Details:
            - Repository: ${{ github.repository }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}

            To approve this deployment:
            - Comment '/approve' on this issue

            To deny:
            - Comment '/deny' on this issue"

      - name: Wait for Approval
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            ISSUE=$(gh issue list --limit 1)
            ISSUE_NUMBER=$(echo "$ISSUE" | awk '{print $1}')

            COMMENTS=$(gh issue view $ISSUE_NUMBER --comments)

            if echo "$COMMENTS" | grep -qE "(/approve|LGTM|looks good)"; then
              echo "Deployment approved!"
              exit 0
            fi

            if echo "$COMMENTS" | grep -q "/deny"; then
              echo "Deployment denied!"
              exit 1
            fi

            sleep 30
            attempt=$((attempt + 1))
          done

          echo "Approval timeout reached"
          exit 1

  build-and-push:
    needs: create-approval
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  blue-green-deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Determine Current Active Service
        id: current-service
        run: |
          CURRENT_SERVICE=$(aws ecs describe-services \
            --cluster my-nginx-prod-cluster \
            --services my-nginx-service \
            --query 'services[0].serviceName' \
            --output text)
          
          if [ "$CURRENT_SERVICE" == "my-nginx-service" ]; then
            echo "BLUE_SERVICE=my-nginx-service" >> $GITHUB_ENV
            echo "GREEN_SERVICE=my-nginx-service-green" >> $GITHUB_ENV
          else
            echo "BLUE_SERVICE=my-nginx-service-green" >> $GITHUB_ENV
            echo "GREEN_SERVICE=my-nginx-service" >> $GITHUB_ENV
          fi

      - name: Create Green Service if Not Exists
        run: |
          if ! aws ecs describe-services \
            --cluster my-nginx-prod-cluster \
            --services ${{ env.GREEN_SERVICE }} \
            2>/dev/null; then
            
            aws ecs create-service \
              --cluster my-nginx-prod-cluster \
              --service-name ${{ env.GREEN_SERVICE }} \
              --task-definition my-nginx-task:latest \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${{ secrets.PUBLIC_SUBNET_IDS }}],securityGroups=[${{ secrets.SECURITY_GROUP }}],assignPublicIp=ENABLED}"
          fi

      - name: Update Green Service with New Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-nginx-app
        run: |
          # Update task definition with new image
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --family my-nginx-task \
            --container-definitions "[{
              \"name\": \"nginx-container\",
              \"image\": \"$ECR_REGISTRY/$ECR_REPOSITORY:${{ github.sha }}\",
              \"portMappings\": [{
                \"containerPort\": 80,
                \"hostPort\": 80,
                \"protocol\": \"tcp\"
              }]
            }]" \
            --requires-compatibilities FARGATE \
            --network-mode awsvpc \
            --cpu 256 \
            --memory 512 \
            --execution-role-arn ${{ secrets.EXECUTION_ROLE_ARN }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          aws ecs update-service \
            --cluster my-nginx-prod-cluster \
            --service ${{ env.GREEN_SERVICE }} \
            --task-definition $NEW_TASK_DEF

      - name: Perform Health Checks on Green Service
        run: |
          # Implement your health check logic here
          # For example, wait for service to stabilize and pass health checks
          aws ecs wait services-stable \
            --cluster my-nginx-prod-cluster \
            --services ${{ env.GREEN_SERVICE }}

      - name: Swap Services
        run: |
          # Stop the blue service
          aws ecs update-service \
            --cluster my-nginx-prod-cluster \
            --service ${{ env.BLUE_SERVICE }} \
            --desired-count 0

          # Update load balancer to point to new service
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
            --names my-nginx-tg \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)

          # Modify load balancer listener
          aws elbv2 modify-listener \
            --listener-arn ${{ secrets.LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN