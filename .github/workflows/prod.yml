name: Production Workflow

on:
  push:
    branches:
      - master

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 908027419539.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: my-nginx-app
  ECS_CLUSTER: my-nginx-prod-cluster
  ECS_SERVICE: my-nginx-prod-service
  GREEN_SERVICE_NAME: my-nginx-green-service

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        id: login-ecr

      - name: Build, tag, and push image to Amazon ECR
        env:
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Task Definition
        id: task-def
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Force Delete Existing Green Service
        run: |
          # Verificar el estado actual del servicio
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $GREEN_SERVICE_NAME \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "INACTIVE")
            
          echo "Current service status: $SERVICE_STATUS"
          
          # Si el servicio existe (no está INACTIVE)
          if [ "$SERVICE_STATUS" != "INACTIVE" ]; then
            # Si el servicio está en DRAINING, esperamos a que termine
            if [ "$SERVICE_STATUS" == "DRAINING" ]; then
              echo "Service is in DRAINING state, waiting for completion..."
              aws ecs delete-service \
                --cluster $ECS_CLUSTER \
                --service $GREEN_SERVICE_NAME \
                --force || true
            else
              # Si el servicio está ACTIVE, intentamos eliminarlo
              aws ecs delete-service \
                --cluster $ECS_CLUSTER \
                --service $GREEN_SERVICE_NAME \
                --force || true
            fi
          fi

      - name: Wait for Service Deletion
        run: |
          max_attempts=12
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $GREEN_SERVICE_NAME \
              --query 'services[0].[status,runningCount]' \
              --output text 2>/dev/null || echo "INACTIVE 0")
            
            echo "Service check result: $SERVICE_STATUS"
            
            if [ "$SERVICE_STATUS" == "INACTIVE 0" ] || echo "$SERVICE_STATUS" | grep -q "MISSING"; then
              echo "Service is fully deleted"
              break
            fi
            
            # Si aún existe el servicio pero no tiene tareas, intentamos forzar la eliminación nuevamente
            if echo "$SERVICE_STATUS" | grep -q " 0$"; then
              echo "No running tasks, attempting force delete again..."
              aws ecs delete-service \
                --cluster $ECS_CLUSTER \
                --service $GREEN_SERVICE_NAME \
                --force || true
            fi
            
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
              echo "Timeout reached, but proceeding since service should be inactive"
              break
            fi
            
            echo "Attempt $attempt of $max_attempts, waiting 5 seconds..."
            sleep 5
          done

      - name: Create Green Service
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
          PUBLIC_SUBNET_IDS: subnet-05b5533b0a8602474,subnet-095b0b27bd626d558,subnet-0247dff8cb76adddf
          SECURITY_GROUP: sg-0e2f023a42da0b442
        run: |
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name $GREEN_SERVICE_NAME \
            --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_IDS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --load-balancers targetGroupArn=$GREEN_TARGET_GROUP_ARN,containerName=my-nginx-app,containerPort=80

      - name: Verify Green Deployment
        env:
          GREEN_TARGET_GROUP_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
        run: |
          # Esperar a que el servicio esté estable
          sleep 30
          
          # Obtener el ARN de la tarea usando --query directamente
          TASK_ARN=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $GREEN_SERVICE_NAME \
            --query 'taskArns[0]' \
            --output text)

          # Debug: Print the task ARN
          echo "Task ARN: $TASK_ARN"

          # Verificar si se obtuvo un ARN válido
          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" == "null" ]; then
            echo "No se encontró ninguna tarea en ejecución"
            exit 1
          fi

          # Wait for the specific task to reach a steady state
          max_attempts=20
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            # Describe the task to get its status
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks "$TASK_ARN" \
              --query 'tasks[0].lastStatus' \
              --output text)

            echo "Task Status: $TASK_STATUS"

            # Check target group health
            TARGET_HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn $GREEN_TARGET_GROUP_ARN \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)

            echo "Target Health: $TARGET_HEALTH"

            # Break if task is RUNNING and target is healthy
            if [[ "$TASK_STATUS" == "RUNNING" ]] && [[ "$TARGET_HEALTH" == "healthy" ]]; then
              echo "Task is running and healthy"
              break
            fi

            # Si la tarea falló, salir con error
            if [[ "$TASK_STATUS" == "STOPPED" ]]; then
              echo "Task stopped unexpectedly"
              exit 1
            fi

            attempt=$((attempt + 1))
            echo "Attempt $attempt of $max_attempts"
            sleep 30
          done

          # Verificar si se alcanzó el máximo de intentos
          if [ $attempt -eq $max_attempts ]; then
            echo "Se alcanzó el máximo número de intentos sin éxito"
            exit 1
          fi

          # HTTP request to verify application
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.ALB_DNS }})
          echo "HTTP Response Code: $RESPONSE"

          if [ "$RESPONSE" != "200" ]; then
            echo "La aplicación no está respondiendo correctamente"
            exit 1
          fi

          echo "Green Deployment verified successfully"

      - name: Switch Traffic to Green
        run: |
          aws elbv2 modify-rule \
            --rule-arn ${{ secrets.GREEN_LISTENER_RULE_ARN }} \
            --actions Type=forward,TargetGroupArn=${{ secrets.GREEN_TARGET_GROUP_ARN }}

      - name: Clean Up Old Blue Service
        run: |
          aws ecs delete-service \
            --cluster $ECS_CLUSTER \
            --service my-nginx-prod-service \
            --force || true

      - name: Verify Final Deployment
        env:
          ALB_DNS: ${{ secrets.ALB_DNS }}
        run: |
          # Wait for load balancer to route to new service
          sleep 30

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS)

          if [ "$RESPONSE" != "200" ]; then
            echo "Final deployment verification failed"
            exit 1
          fi

          echo "Blue-Green deployment completed successfully"